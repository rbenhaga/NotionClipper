{"file":"C:\\Users\\rayan\\Desktop\\Dev\\NotionClipper\\packages\\notion-parser\\src\\converters\\RichTextConverter.ts","mappings":"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","names":[],"sources":["C:\\Users\\rayan\\Desktop\\Dev\\NotionClipper\\packages\\notion-parser\\src\\converters\\RichTextConverter.ts"],"sourcesContent":["import type { NotionRichText, NotionColor } from '../types';\r\n\r\ninterface TextToken {\r\n  type: 'text' | 'bold' | 'italic' | 'code' | 'strikethrough' | 'underline' | 'link' | 'auto-link' | 'equation' | 'bold-italic';\r\n  content: string;\r\n  start: number;\r\n  end: number;\r\n  url?: string;\r\n  expression?: string;\r\n}\r\n\r\n\r\n\r\nexport class RichTextConverter {\r\n  parseRichText(text: string, options?: { convertLinks?: boolean }): NotionRichText[] {\r\n    if (!text) return [];\r\n\r\n    // Traiter les échappements d'abord\r\n    const processedText = this.processEscapes(text);\r\n\r\n    // Nouvelle approche: tokenisation puis reconstruction\r\n    const tokens = this.tokenizeText(processedText, options);\r\n    return this.tokensToRichText(tokens, processedText);\r\n  }\r\n\r\n  private processEscapes(text: string): string {\r\n    // Remplacer les échappements par des placeholders temporaires\r\n    const escapeMap = new Map<string, string>();\r\n    let counter = 0;\r\n\r\n    // Traiter les échappements de caractères spéciaux\r\n    const escapedChars = ['*', '_', '`', '~', '[', ']', '(', ')', '$'];\r\n\r\n    let result = text;\r\n\r\n    escapedChars.forEach(char => {\r\n      const escapedPattern = new RegExp(`\\\\\\\\\\\\${char}`, 'g');\r\n      result = result.replace(escapedPattern, () => {\r\n        const placeholder = `§ESC${counter++}§`;\r\n        escapeMap.set(placeholder, char);\r\n        return placeholder;\r\n      });\r\n    });\r\n\r\n    // Stocker la map pour la restauration\r\n    (this as any)._escapeMap = escapeMap;\r\n\r\n    return result;\r\n  }\r\n\r\n  private restoreEscapes(text: string): string {\r\n    const escapeMap = (this as any)._escapeMap as Map<string, string>;\r\n    if (!escapeMap) return text;\r\n\r\n    let result = text;\r\n    escapeMap.forEach((char, placeholder) => {\r\n      result = result.replace(new RegExp(placeholder, 'g'), char);\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  private tokenizeText(text: string, options?: { convertLinks?: boolean }): TextToken[] {\r\n\r\n    // Définir tous les patterns avec leurs priorités\r\n    const patterns: Array<{ regex: RegExp; type: TextToken['type']; priority: number }> = [\r\n      // Équations (priorité la plus haute - pas d'imbrication)\r\n      { regex: /\\$([^$]+)\\$/g, type: 'equation', priority: 1 },\r\n\r\n      // Code inline (priorité haute - peut être imbriqué)\r\n      { regex: /`([^`]+)`/g, type: 'code', priority: 2 },\r\n\r\n      // Bold + Italic (***text***)\r\n      { regex: /\\*\\*\\*([^*]+)\\*\\*\\*/g, type: 'bold-italic', priority: 4 },\r\n\r\n      // Bold (**text**)\r\n      { regex: /\\*\\*([^*]+)\\*\\*/g, type: 'bold', priority: 5 },\r\n\r\n      // Underline (__text__)\r\n      { regex: /__([^_]+)__/g, type: 'underline', priority: 6 },\r\n\r\n      // Italic (*text* or _text_)\r\n      { regex: /\\*([^*]+)\\*/g, type: 'italic', priority: 7 },\r\n      { regex: /_([^_]+)_/g, type: 'italic', priority: 7 },\r\n\r\n      // Strikethrough (~~text~~)\r\n      { regex: /~~([^~]+)~~/g, type: 'strikethrough', priority: 8 }\r\n    ];\r\n\r\n    // Ajouter les patterns de liens seulement si convertLinks n'est pas false\r\n    if (options?.convertLinks !== false) {\r\n      patterns.push(\r\n        // Links (priorité haute - peut contenir du formatage)\r\n        { regex: /\\[([^\\]]+)\\]\\(([^)]+)\\)/g, type: 'link', priority: 3 },\r\n\r\n        // URLs auto-détectées (priorité haute)\r\n        { regex: /(https?:\\/\\/[^\\s<>\"{}|\\\\^`[\\]]+)/g, type: 'auto-link', priority: 3 }\r\n      );\r\n    }\r\n\r\n    // Trouver tous les matches avec leurs positions\r\n    const allMatches: Array<{\r\n      match: RegExpExecArray;\r\n      type: string;\r\n      priority: number;\r\n      start: number;\r\n      end: number;\r\n      content: string;\r\n      url?: string;\r\n      expression?: string;\r\n    }> = [];\r\n\r\n    patterns.forEach(pattern => {\r\n      let match;\r\n      const regex = new RegExp(pattern.regex.source, 'g');\r\n\r\n      while ((match = regex.exec(text)) !== null) {\r\n        const start = match.index;\r\n        const end = match.index + match[0].length;\r\n\r\n        let content = match[1];\r\n        let url: string | undefined;\r\n        let expression: string | undefined;\r\n\r\n        if (pattern.type === 'link') {\r\n          content = match[1];\r\n          url = match[2];\r\n        } else if (pattern.type === 'auto-link') {\r\n          content = match[1];\r\n          url = match[1];\r\n        } else if (pattern.type === 'equation') {\r\n          expression = match[1];\r\n          content = match[1];\r\n        } else if (pattern.type === 'bold-italic') {\r\n          // Traiter comme bold ET italic\r\n          allMatches.push({\r\n            match,\r\n            type: 'bold',\r\n            priority: pattern.priority,\r\n            start,\r\n            end,\r\n            content\r\n          });\r\n          allMatches.push({\r\n            match,\r\n            type: 'italic',\r\n            priority: pattern.priority,\r\n            start,\r\n            end,\r\n            content\r\n          });\r\n          continue;\r\n        }\r\n\r\n        allMatches.push({\r\n          match,\r\n          type: pattern.type,\r\n          priority: pattern.priority,\r\n          start,\r\n          end,\r\n          content,\r\n          url,\r\n          expression\r\n        });\r\n      }\r\n    });\r\n\r\n    // Trier par position puis par priorité\r\n    allMatches.sort((a, b) => {\r\n      if (a.start !== b.start) return a.start - b.start;\r\n      return a.priority - b.priority;\r\n    });\r\n\r\n    return allMatches.map(m => ({\r\n      type: m.type as TextToken['type'],\r\n      content: m.content,\r\n      start: m.start,\r\n      end: m.end,\r\n      url: m.url,\r\n      expression: m.expression\r\n    }));\r\n  }\r\n\r\n  private tokensToRichText(tokens: TextToken[], originalText: string): NotionRichText[] {\r\n    if (tokens.length === 0) {\r\n      return [{\r\n        type: 'text',\r\n        text: { content: this.restoreEscapes(originalText) }\r\n      }];\r\n    }\r\n\r\n    const result: NotionRichText[] = [];\r\n    const segments = this.createSegments(tokens, originalText);\r\n\r\n    segments.forEach(segment => {\r\n      if (segment.type === 'equation') {\r\n        result.push({\r\n          type: 'equation',\r\n          equation: { expression: segment.expression || segment.content }\r\n        });\r\n      } else {\r\n        const annotations: any = {};\r\n\r\n        // Appliquer toutes les annotations qui s'appliquent à ce segment\r\n        if (segment.bold) annotations.bold = true;\r\n        if (segment.italic) annotations.italic = true;\r\n        if (segment.code) annotations.code = true;\r\n        if (segment.strikethrough) annotations.strikethrough = true;\r\n        if (segment.underline) annotations.underline = true;\r\n\r\n        const textContent: any = { content: segment.content };\r\n        if (segment.link) {\r\n          textContent.link = { url: segment.link.url };\r\n        }\r\n\r\n        // Restaurer les échappements dans le contenu\r\n        textContent.content = this.restoreEscapes(textContent.content);\r\n\r\n        result.push({\r\n          type: 'text',\r\n          text: textContent,\r\n          annotations: Object.keys(annotations).length > 0 ? annotations : undefined,\r\n          href: segment.link ? segment.link.url : null\r\n        });\r\n      }\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  private createSegments(tokens: TextToken[], originalText: string): Array<{\r\n    content: string;\r\n    start: number;\r\n    end: number;\r\n    type: 'text' | 'equation';\r\n    bold?: boolean;\r\n    italic?: boolean;\r\n    code?: boolean;\r\n    strikethrough?: boolean;\r\n    underline?: boolean;\r\n    link?: { url: string };\r\n    expression?: string;\r\n  }> {\r\n    // Créer une liste de tous les points de changement\r\n    const changePoints = new Set<number>();\r\n    changePoints.add(0);\r\n    changePoints.add(originalText.length);\r\n\r\n    tokens.forEach(token => {\r\n      changePoints.add(token.start);\r\n      changePoints.add(token.end);\r\n    });\r\n\r\n    const sortedPoints = Array.from(changePoints).sort((a, b) => a - b);\r\n    const segments: Array<{\r\n      content: string;\r\n      start: number;\r\n      end: number;\r\n      type: 'text' | 'equation';\r\n      bold?: boolean;\r\n      italic?: boolean;\r\n      code?: boolean;\r\n      strikethrough?: boolean;\r\n      underline?: boolean;\r\n      link?: { url: string };\r\n      expression?: string;\r\n    }> = [];\r\n\r\n    // Créer des segments entre chaque point de changement\r\n    for (let i = 0; i < sortedPoints.length - 1; i++) {\r\n      const start = sortedPoints[i];\r\n      const end = sortedPoints[i + 1];\r\n\r\n      if (start === end) continue;\r\n\r\n      const content = originalText.slice(start, end);\r\n      if (!content) continue;\r\n\r\n      // Déterminer quels tokens s'appliquent à ce segment\r\n      const applicableTokens = tokens.filter(token => {\r\n        // Un token s'applique si le segment est complètement à l'intérieur du token\r\n        return token.start <= start && end <= token.end;\r\n      });\r\n\r\n      // Vérifier si c'est une équation (priorité absolue)\r\n      const equationToken = applicableTokens.find(t => t.type === 'equation');\r\n      if (equationToken) {\r\n        segments.push({\r\n          content: equationToken.content,\r\n          start,\r\n          end,\r\n          type: 'equation',\r\n          expression: equationToken.expression\r\n        });\r\n        continue;\r\n      }\r\n\r\n      // Construire les annotations pour ce segment\r\n      const segment: any = {\r\n        content,\r\n        start,\r\n        end,\r\n        type: 'text'\r\n      };\r\n\r\n      applicableTokens.forEach(token => {\r\n        switch (token.type) {\r\n          case 'bold':\r\n            segment.bold = true;\r\n            break;\r\n          case 'italic':\r\n            segment.italic = true;\r\n            break;\r\n          case 'code':\r\n            segment.code = true;\r\n            break;\r\n          case 'strikethrough':\r\n            segment.strikethrough = true;\r\n            break;\r\n          case 'underline':\r\n            segment.underline = true;\r\n            break;\r\n          case 'link':\r\n          case 'auto-link':\r\n            segment.link = { url: token.url! };\r\n            break;\r\n        }\r\n      });\r\n\r\n      segments.push(segment);\r\n    }\r\n\r\n    // Filtrer les segments vides et fusionner les segments adjacents identiques\r\n    return this.mergeAdjacentSegments(segments.filter(s => s.content.trim() || s.type === 'equation'));\r\n  }\r\n\r\n  private mergeAdjacentSegments(segments: any[]): any[] {\r\n    if (segments.length <= 1) return segments;\r\n\r\n    const merged: any[] = [];\r\n    let current = { ...segments[0] };\r\n\r\n    for (let i = 1; i < segments.length; i++) {\r\n      const next = segments[i];\r\n\r\n      // Vérifier si les segments peuvent être fusionnés\r\n      if (this.canMergeSegments(current, next)) {\r\n        current.content += next.content;\r\n        current.end = next.end;\r\n      } else {\r\n        merged.push(current);\r\n        current = { ...next };\r\n      }\r\n    }\r\n\r\n    merged.push(current);\r\n    return merged;\r\n  }\r\n\r\n  private canMergeSegments(a: any, b: any): boolean {\r\n    if (a.type !== b.type) return false;\r\n    if (a.type === 'equation') return false; // Ne jamais fusionner les équations\r\n\r\n    // Comparer toutes les propriétés de formatage\r\n    return a.bold === b.bold &&\r\n      a.italic === b.italic &&\r\n      a.code === b.code &&\r\n      a.strikethrough === b.strikethrough &&\r\n      a.underline === b.underline &&\r\n      JSON.stringify(a.link) === JSON.stringify(b.link);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Convertit du texte simple en rich text\r\n   */\r\n  createSimpleRichText(content: string): NotionRichText[] {\r\n    return [{\r\n      type: 'text',\r\n      text: { content }\r\n    }];\r\n  }\r\n\r\n  /**\r\n   * Crée un rich text avec formatage spécifique\r\n   */\r\n  createFormattedRichText(\r\n    content: string,\r\n    formatting: {\r\n      bold?: boolean;\r\n      italic?: boolean;\r\n      strikethrough?: boolean;\r\n      underline?: boolean;\r\n      code?: boolean;\r\n      color?: NotionColor;\r\n    } = {}\r\n  ): NotionRichText[] {\r\n    return [{\r\n      type: 'text',\r\n      text: { content },\r\n      annotations: formatting\r\n    }];\r\n  }\r\n\r\n  /**\r\n   * Crée un rich text avec lien\r\n   */\r\n  createLinkRichText(content: string, url: string): NotionRichText[] {\r\n    return [{\r\n      type: 'text',\r\n      text: {\r\n        content,\r\n        link: { url }\r\n      }\r\n    }];\r\n  }\r\n\r\n  /**\r\n   * Crée un rich text équation\r\n   */\r\n  createEquationRichText(expression: string): NotionRichText[] {\r\n    return [{\r\n      type: 'equation',\r\n      equation: { expression }\r\n    }];\r\n  }\r\n\r\n  /**\r\n   * Combine plusieurs rich text arrays\r\n   */\r\n  combineRichText(...richTexts: NotionRichText[][]): NotionRichText[] {\r\n    return richTexts.flat();\r\n  }\r\n\r\n  /**\r\n   * Tronque le rich text si nécessaire\r\n   */\r\n  truncateRichText(richText: NotionRichText[], maxLength: number): NotionRichText[] {\r\n    let currentLength = 0;\r\n    const result: NotionRichText[] = [];\r\n\r\n    for (const item of richText) {\r\n      const content = item.type === 'text'\r\n        ? item.text?.content || ''\r\n        : item.type === 'equation'\r\n          ? item.equation?.expression || ''\r\n          : '';\r\n\r\n      if (currentLength + content.length <= maxLength) {\r\n        result.push(item);\r\n        currentLength += content.length;\r\n      } else {\r\n        const remainingLength = maxLength - currentLength;\r\n        if (remainingLength > 10) {\r\n          const truncatedContent = content.substring(0, remainingLength - 10) + '...';\r\n\r\n          if (item.type === 'text') {\r\n            result.push({\r\n              ...item,\r\n              text: {\r\n                ...item.text,\r\n                content: truncatedContent\r\n              }\r\n            });\r\n          } else if (item.type === 'equation') {\r\n            result.push({\r\n              type: 'text',\r\n              text: { content: truncatedContent }\r\n            });\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}"],"version":3}