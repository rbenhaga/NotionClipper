{"file":"C:\\Users\\rayan\\Desktop\\Dev\\NotionClipper\\packages\\notion-parser\\src\\parsers\\TableParser.ts","mappings":";;;AAAA,6CAA0C;AAE1C,mEAAgE;AAEhE,MAAa,WAAY,SAAQ,uBAAU;IACzC,YAAY,UAAwB,EAAE;QACpC,KAAK,CAAC,OAAO,CAAC,CAAC;IACjB,CAAC;IAED,KAAK,CAAC,OAAe;QACnB,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE;YAAE,OAAO,EAAE,CAAC;QAEhC,MAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC;QAE7C,QAAQ,WAAW,EAAE,CAAC;YACpB,KAAK,KAAK;gBACR,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;YAChC,KAAK,KAAK;gBACR,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;YAChC,KAAK,OAAO,CAAC;YACb;gBACE,OAAO,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;QAC5C,CAAC;IACH,CAAC;IAEO,QAAQ,CAAC,OAAe;QAC9B,OAAO,IAAI,CAAC,mBAAmB,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IAChD,CAAC;IAEO,QAAQ,CAAC,OAAe;QAC9B,OAAO,IAAI,CAAC,mBAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IACjD,CAAC;IAEO,mBAAmB,CAAC,OAAe,EAAE,SAAiB;QAC5D,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QAE9D,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACrB,8CAA8C;YAC9C,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC;QACxC,CAAC;QAED,2CAA2C;QAC3C,MAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC;QAEzE,iBAAiB;QACjB,MAAM,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;QACvD,MAAM,YAAY,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAEjD,uCAAuC;QACvC,MAAM,OAAO,GAAG,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QAC/C,MAAM,QAAQ,GAAG,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAExD,wBAAwB;QACxB,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CACzB,OAAO,CAAC,MAAM,EACd,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,CACnC,CAAC;QAEF,MAAM,iBAAiB,GAAG,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QACxF,MAAM,cAAc,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC,CAAC;QAE/E,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,iBAAiB,EAAE,cAAc,EAAE;gBAC9D,eAAe;gBACf,YAAY;aACb,CAAC,CAAC,CAAC;IACN,CAAC;IAEO,kBAAkB,CAAC,IAAY,EAAE,SAAiB;QACxD,MAAM,MAAM,GAAa,EAAE,CAAC;QAC5B,IAAI,OAAO,GAAG,EAAE,CAAC;QACjB,IAAI,QAAQ,GAAG,KAAK,CAAC;QACrB,IAAI,CAAC,GAAG,CAAC,CAAC;QAEV,OAAO,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;YACvB,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YACrB,MAAM,QAAQ,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAE7B,IAAI,IAAI,KAAK,GAAG,EAAE,CAAC;gBACjB,IAAI,QAAQ,IAAI,QAAQ,KAAK,GAAG,EAAE,CAAC;oBACjC,gBAAgB;oBAChB,OAAO,IAAI,GAAG,CAAC;oBACf,CAAC,IAAI,CAAC,CAAC;gBACT,CAAC;qBAAM,CAAC;oBACN,qBAAqB;oBACrB,QAAQ,GAAG,CAAC,QAAQ,CAAC;oBACrB,CAAC,EAAE,CAAC;gBACN,CAAC;YACH,CAAC;iBAAM,IAAI,IAAI,KAAK,SAAS,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAC3C,kBAAkB;gBAClB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;gBAC5B,OAAO,GAAG,EAAE,CAAC;gBACb,CAAC,EAAE,CAAC;YACN,CAAC;iBAAM,CAAC;gBACN,OAAO,IAAI,IAAI,CAAC;gBAChB,CAAC,EAAE,CAAC;YACN,CAAC;QACH,CAAC;QAED,qBAAqB;QACrB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;QAE5B,OAAO,MAAM,CAAC;IAChB,CAAC;IAEO,kBAAkB,CAAC,OAAe;QACxC,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QAE9D,kCAAkC;QAClC,MAAM,UAAU,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;QAE5D,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC1B,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC;QACxC,CAAC;QAED,gBAAgB;QAChB,MAAM,UAAU,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;QACjC,MAAM,OAAO,GAAG,IAAI,CAAC,qBAAqB,CAAC,UAAU,CAAC,CAAC;QAEvD,+CAA+C;QAC/C,IAAI,cAAc,GAAG,CAAC,CAAC;QACvB,IAAI,eAAe,GAAG,KAAK,CAAC;QAE5B,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,uBAAuB,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YACzE,cAAc,GAAG,CAAC,CAAC;YACnB,eAAe,GAAG,IAAI,CAAC;QACzB,CAAC;QAED,kBAAkB;QAClB,MAAM,QAAQ,GAAG,UAAU,CAAC,KAAK,CAAC,cAAc,CAAC;aAC9C,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;aAC7C,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;QAEtD,qBAAqB;QACrB,MAAM,YAAY,GAAG,IAAI,CAAC,gBAAgB,CAAC,CAAC,OAAO,EAAE,GAAG,QAAQ,CAAC,CAAC,CAAC;QAEnE,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,QAAQ,EAAE;gBAC9C,eAAe;gBACf,YAAY;aACb,CAAC,CAAC,CAAC;IACN,CAAC;IAEO,qBAAqB,CAAC,IAAY;QACxC,0CAA0C;QAC1C,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QAC5B,MAAM,iBAAiB,GAAG,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;QAC/E,MAAM,mBAAmB,GAAG,iBAAiB,CAAC,QAAQ,CAAC,GAAG,CAAC;YACzD,CAAC,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAChC,CAAC,CAAC,iBAAiB,CAAC;QAEtB,OAAO,mBAAmB;aACvB,KAAK,CAAC,GAAG,CAAC;aACV,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,mCAAgB,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;aAC5D,MAAM,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE;YAC7B,8CAA8C;YAC9C,OAAO,CAAC,CAAC,IAAI,KAAK,EAAE,IAAI,CAAC,KAAK,KAAK,CAAC,IAAI,KAAK,KAAK,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QACvE,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,uBAAuB,CAAC,IAAY;QAC1C,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QAC5B,kDAAkD;QAClD,OAAO,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;IAC/D,CAAC;IAEO,YAAY,CAAC,GAAa,EAAE,YAAoB;QACtD,MAAM,UAAU,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;QAE5B,sCAAsC;QACtC,OAAO,UAAU,CAAC,MAAM,GAAG,YAAY,EAAE,CAAC;YACxC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QACtB,CAAC;QAED,uBAAuB;QACvB,IAAI,UAAU,CAAC,MAAM,GAAG,YAAY,EAAE,CAAC;YACrC,UAAU,CAAC,MAAM,GAAG,YAAY,CAAC;QACnC,CAAC;QAED,OAAO,UAAU,CAAC;IACpB,CAAC;IAED;;OAEG;IACK,mBAAmB,CAAC,IAAgB;QAC1C,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC;YAAE,OAAO,KAAK,CAAC;QAElC,MAAM,QAAQ,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QACzB,MAAM,SAAS,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QAE1B,2CAA2C;QAC3C,2EAA2E;QAC3E,MAAM,eAAe,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAC3C,IAAI,IAAI,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,CAClD,CAAC;QAEF,MAAM,mBAAmB,GAAG,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAChD,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAC7B,CAAC;QAEF,mEAAmE;QACnE,MAAM,iBAAiB,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC;QACjG,MAAM,kBAAkB,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC;QAEpG,0DAA0D;QAC1D,MAAM,cAAc,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;QAC3F,MAAM,iBAAiB,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAC7C,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAC5B,IAAI,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC,CACrC,CACF,CAAC;QAEF,OAAO,CAAC,eAAe,IAAI,mBAAmB,CAAC;YACxC,CAAC,iBAAiB,GAAG,kBAAkB,GAAG,GAAG,CAAC;YAC9C,iBAAiB,CAAC;IAC3B,CAAC;IAED;;OAEG;IACK,gBAAgB,CAAC,IAAgB;QACvC,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC;YAAE,OAAO,KAAK,CAAC;QAExD,+DAA+D;QAC/D,wEAAwE;QACxE,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QAChF,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QAE9F,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO,KAAK,CAAC;QAExE,6CAA6C;QAC7C,MAAM,oBAAoB,GAAG,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;QAEzG,6CAA6C;QAC7C,MAAM,wBAAwB,GAAG,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,YAAY,CAAC,MAAM,CAAC;QAEhH,OAAO,oBAAoB,GAAG,GAAG,IAAI,wBAAwB,GAAG,GAAG,CAAC;IACtE,CAAC;IAED;;OAEG;IACO,eAAe,CAAC,OAAiB,EAAE,IAAgB,EAAE,UAG3D,EAAE,eAAe,EAAE,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE;QACjD,OAAO;YACL,IAAI,EAAE,OAAO;YACb,OAAO,EAAE,EAAE;YACX,QAAQ,EAAE;gBACR,OAAO;gBACP,IAAI;gBACJ,WAAW,EAAE,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBACrE,QAAQ,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACzD,eAAe,EAAE,OAAO,CAAC,eAAe;gBACxC,YAAY,EAAE,OAAO,CAAC,YAAY;aACnC;YACD,QAAQ,EAAE,EAAE;SACb,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,iBAAiB,CAAC,OAAe;QACtC,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QAE9D,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC;YAAE,OAAO,MAAM,CAAC;QAEpC,2BAA2B;QAC3B,MAAM,SAAS,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC;QAClE,IAAI,SAAS,IAAI,CAAC,IAAI,SAAS,GAAG,KAAK,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC;YACrD,OAAO,UAAU,CAAC;QACpB,CAAC;QAED,gCAAgC;QAChC,MAAM,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC;QAClE,IAAI,QAAQ,GAAG,KAAK,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC;YAClC,OAAO,KAAK,CAAC;QACf,CAAC;QAED,kCAAkC;QAClC,MAAM,UAAU,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC;QACnE,IAAI,UAAU,GAAG,KAAK,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC;YACpC,OAAO,KAAK,CAAC;QACf,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA5RD,kCA4RC","names":[],"sources":["C:\\Users\\rayan\\Desktop\\Dev\\NotionClipper\\packages\\notion-parser\\src\\parsers\\TableParser.ts"],"sourcesContent":["import { BaseParser } from './BaseParser';\r\nimport type { ASTNode, ParseOptions } from '../types';\r\nimport { ContentSanitizer } from '../security/ContentSanitizer';\r\n\r\nexport class TableParser extends BaseParser {\r\n  constructor(options: ParseOptions = {}) {\r\n    super(options);\r\n  }\r\n\r\n  parse(content: string): ASTNode[] {\r\n    if (!content?.trim()) return [];\r\n\r\n    const contentType = this.options.contentType;\r\n    \r\n    switch (contentType) {\r\n      case 'csv':\r\n        return this.parseCsv(content);\r\n      case 'tsv':\r\n        return this.parseTsv(content);\r\n      case 'table':\r\n      default:\r\n        return this.parseMarkdownTable(content);\r\n    }\r\n  }\r\n\r\n  private parseCsv(content: string): ASTNode[] {\r\n    return this.parseDelimitedTable(content, ',');\r\n  }\r\n\r\n  private parseTsv(content: string): ASTNode[] {\r\n    return this.parseDelimitedTable(content, '\\t');\r\n  }\r\n\r\n  private parseDelimitedTable(content: string, delimiter: string): ASTNode[] {\r\n    const lines = content.split('\\n').filter(line => line.trim());\r\n    \r\n    if (lines.length < 2) {\r\n      // Not enough data for a table, return as text\r\n      return [this.createTextNode(content)];\r\n    }\r\n\r\n    // Parse CSV/TSV with proper quote handling\r\n    const rows = lines.map(line => this.parseDelimitedLine(line, delimiter));\r\n    \r\n    // Detect headers\r\n    const hasColumnHeader = this.detectColumnHeaders(rows);\r\n    const hasRowHeader = this.detectRowHeaders(rows);\r\n    \r\n    // Use first row as headers if detected\r\n    const headers = hasColumnHeader ? rows[0] : [];\r\n    const dataRows = hasColumnHeader ? rows.slice(1) : rows;\r\n\r\n    // Normalize row lengths\r\n    const maxColumns = Math.max(\r\n      headers.length, \r\n      ...dataRows.map(row => row.length)\r\n    );\r\n    \r\n    const normalizedHeaders = hasColumnHeader ? this.normalizeRow(headers, maxColumns) : [];\r\n    const normalizedRows = dataRows.map(row => this.normalizeRow(row, maxColumns));\r\n\r\n    return [this.createTableNode(normalizedHeaders, normalizedRows, {\r\n      hasColumnHeader,\r\n      hasRowHeader\r\n    })];\r\n  }\r\n\r\n  private parseDelimitedLine(line: string, delimiter: string): string[] {\r\n    const result: string[] = [];\r\n    let current = '';\r\n    let inQuotes = false;\r\n    let i = 0;\r\n\r\n    while (i < line.length) {\r\n      const char = line[i];\r\n      const nextChar = line[i + 1];\r\n\r\n      if (char === '\"') {\r\n        if (inQuotes && nextChar === '\"') {\r\n          // Escaped quote\r\n          current += '\"';\r\n          i += 2;\r\n        } else {\r\n          // Toggle quote state\r\n          inQuotes = !inQuotes;\r\n          i++;\r\n        }\r\n      } else if (char === delimiter && !inQuotes) {\r\n        // Field separator\r\n        result.push(current.trim());\r\n        current = '';\r\n        i++;\r\n      } else {\r\n        current += char;\r\n        i++;\r\n      }\r\n    }\r\n\r\n    // Add the last field\r\n    result.push(current.trim());\r\n\r\n    return result;\r\n  }\r\n\r\n  private parseMarkdownTable(content: string): ASTNode[] {\r\n    const lines = content.split('\\n').filter(line => line.trim());\r\n    \r\n    // Find table lines (containing |)\r\n    const tableLines = lines.filter(line => line.includes('|'));\r\n    \r\n    if (tableLines.length < 2) {\r\n      return [this.createTextNode(content)];\r\n    }\r\n\r\n    // Parse headers\r\n    const headerLine = tableLines[0];\r\n    const headers = this.parseMarkdownTableRow(headerLine);\r\n\r\n    // Check for separator line (indicates headers)\r\n    let dataStartIndex = 1;\r\n    let hasColumnHeader = false;\r\n    \r\n    if (tableLines.length > 1 && this.isMarkdownSeparatorLine(tableLines[1])) {\r\n      dataStartIndex = 2;\r\n      hasColumnHeader = true;\r\n    }\r\n\r\n    // Parse data rows\r\n    const dataRows = tableLines.slice(dataStartIndex)\r\n      .map(line => this.parseMarkdownTableRow(line))\r\n      .map(row => this.normalizeRow(row, headers.length));\r\n\r\n    // Detect row headers\r\n    const hasRowHeader = this.detectRowHeaders([headers, ...dataRows]);\r\n\r\n    return [this.createTableNode(headers, dataRows, {\r\n      hasColumnHeader,\r\n      hasRowHeader\r\n    })];\r\n  }\r\n\r\n  private parseMarkdownTableRow(line: string): string[] {\r\n    // Remove leading/trailing pipes and split\r\n    const trimmed = line.trim();\r\n    const withoutOuterPipes = trimmed.startsWith('|') ? trimmed.slice(1) : trimmed;\r\n    const withoutTrailingPipe = withoutOuterPipes.endsWith('|') \r\n      ? withoutOuterPipes.slice(0, -1) \r\n      : withoutOuterPipes;\r\n\r\n    return withoutTrailingPipe\r\n      .split('|')\r\n      .map(cell => ContentSanitizer.sanitizeTableCell(cell.trim()))\r\n      .filter((cell, index, array) => {\r\n        // Remove empty cells at the beginning and end\r\n        return !(cell === '' && (index === 0 || index === array.length - 1));\r\n      });\r\n  }\r\n\r\n  private isMarkdownSeparatorLine(line: string): boolean {\r\n    const trimmed = line.trim();\r\n    // Check if line contains only |, -, :, and spaces\r\n    return /^[\\|\\-:\\s]+$/.test(trimmed) && trimmed.includes('-');\r\n  }\r\n\r\n  private normalizeRow(row: string[], targetLength: number): string[] {\r\n    const normalized = [...row];\r\n    \r\n    // Pad with empty strings if too short\r\n    while (normalized.length < targetLength) {\r\n      normalized.push('');\r\n    }\r\n    \r\n    // Truncate if too long\r\n    if (normalized.length > targetLength) {\r\n      normalized.length = targetLength;\r\n    }\r\n    \r\n    return normalized;\r\n  }\r\n\r\n  /**\r\n   * Détecte si la première ligne contient des headers de colonnes\r\n   */\r\n  private detectColumnHeaders(rows: string[][]): boolean {\r\n    if (rows.length < 2) return false;\r\n    \r\n    const firstRow = rows[0];\r\n    const secondRow = rows[1];\r\n    \r\n    // Heuristiques pour détecter les headers :\r\n    // 1. Première ligne contient du texte, deuxième ligne contient des nombres\r\n    const firstRowHasText = firstRow.some(cell => \r\n      cell && isNaN(Number(cell)) && cell.trim() !== ''\r\n    );\r\n    \r\n    const secondRowHasNumbers = secondRow.some(cell => \r\n      cell && !isNaN(Number(cell))\r\n    );\r\n    \r\n    // 2. Première ligne a des cellules plus longues (noms descriptifs)\r\n    const avgFirstRowLength = firstRow.reduce((sum, cell) => sum + cell.length, 0) / firstRow.length;\r\n    const avgSecondRowLength = secondRow.reduce((sum, cell) => sum + cell.length, 0) / secondRow.length;\r\n    \r\n    // 3. Première ligne contient des mots typiques de headers\r\n    const headerKeywords = ['name', 'id', 'date', 'title', 'type', 'status', 'value', 'count'];\r\n    const hasHeaderKeywords = firstRow.some(cell => \r\n      headerKeywords.some(keyword => \r\n        cell.toLowerCase().includes(keyword)\r\n      )\r\n    );\r\n    \r\n    return (firstRowHasText && secondRowHasNumbers) || \r\n           (avgFirstRowLength > avgSecondRowLength * 1.2) ||\r\n           hasHeaderKeywords;\r\n  }\r\n\r\n  /**\r\n   * Détecte si la première colonne contient des headers de lignes\r\n   */\r\n  private detectRowHeaders(rows: string[][]): boolean {\r\n    if (rows.length < 2 || rows[0].length < 2) return false;\r\n    \r\n    // Vérifier si la première colonne contient du texte descriptif\r\n    // tandis que les autres colonnes contiennent principalement des données\r\n    const firstColumn = rows.map(row => row[0]).filter(cell => cell && cell.trim());\r\n    const otherColumns = rows.map(row => row.slice(1)).flat().filter(cell => cell && cell.trim());\r\n    \r\n    if (firstColumn.length === 0 || otherColumns.length === 0) return false;\r\n    \r\n    // Première colonne majoritairement textuelle\r\n    const firstColumnTextRatio = firstColumn.filter(cell => isNaN(Number(cell))).length / firstColumn.length;\r\n    \r\n    // Autres colonnes majoritairement numériques\r\n    const otherColumnsNumericRatio = otherColumns.filter(cell => !isNaN(Number(cell))).length / otherColumns.length;\r\n    \r\n    return firstColumnTextRatio > 0.7 && otherColumnsNumericRatio > 0.5;\r\n  }\r\n\r\n  /**\r\n   * Crée un nœud table avec les métadonnées de headers\r\n   */\r\n  protected createTableNode(headers: string[], rows: string[][], options: {\r\n    hasColumnHeader: boolean;\r\n    hasRowHeader: boolean;\r\n  } = { hasColumnHeader: false, hasRowHeader: false }): ASTNode {\r\n    return {\r\n      type: 'table',\r\n      content: '',\r\n      metadata: {\r\n        headers,\r\n        rows,\r\n        columnCount: Math.max(headers.length, ...rows.map(row => row.length)),\r\n        rowCount: rows.length + (options.hasColumnHeader ? 1 : 0),\r\n        hasColumnHeader: options.hasColumnHeader,\r\n        hasRowHeader: options.hasRowHeader\r\n      },\r\n      children: []\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Detect table format from content\r\n   */\r\n  static detectTableFormat(content: string): 'csv' | 'tsv' | 'markdown' | 'none' {\r\n    const lines = content.split('\\n').filter(line => line.trim());\r\n    \r\n    if (lines.length < 2) return 'none';\r\n\r\n    // Check for markdown table\r\n    const pipeLines = lines.filter(line => line.includes('|')).length;\r\n    if (pipeLines >= 2 && pipeLines / lines.length > 0.5) {\r\n      return 'markdown';\r\n    }\r\n\r\n    // Check for TSV (tab-separated)\r\n    const tabLines = lines.filter(line => line.includes('\\t')).length;\r\n    if (tabLines / lines.length > 0.7) {\r\n      return 'tsv';\r\n    }\r\n\r\n    // Check for CSV (comma-separated)\r\n    const commaLines = lines.filter(line => line.includes(',')).length;\r\n    if (commaLines / lines.length > 0.7) {\r\n      return 'csv';\r\n    }\r\n\r\n    return 'none';\r\n  }\r\n}"],"version":3}