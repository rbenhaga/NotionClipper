{"file":"C:\\Users\\rayan\\Desktop\\Dev\\NotionClipper\\packages\\notion-parser\\src\\parsers\\LatexParser.ts","mappings":"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","names":[],"sources":["C:\\Users\\rayan\\Desktop\\Dev\\NotionClipper\\packages\\notion-parser\\src\\parsers\\LatexParser.ts"],"sourcesContent":["import { BaseParser } from './BaseParser';\r\nimport type { ASTNode, ParseOptions } from '../types';\r\n\r\nexport class LatexParser extends BaseParser {\r\n  private readonly maxEquationLength = 1000;\r\n\r\n  constructor(options: ParseOptions = {}) {\r\n    super(options);\r\n  }\r\n\r\n  parse(content: string): ASTNode[] {\r\n    if (!content?.trim()) return [];\r\n\r\n    const nodes: ASTNode[] = [];\r\n    const lines = content.split('\\n');\r\n    let i = 0;\r\n\r\n    while (i < lines.length) {\r\n      const line = lines[i].trim();\r\n\r\n      // Block equations ($$...$$)\r\n      if (line.startsWith('$$')) {\r\n        const { node, consumed } = this.parseBlockEquation(lines, i);\r\n        if (node) nodes.push(node);\r\n        i += consumed;\r\n        continue;\r\n      }\r\n\r\n      // LaTeX environments\r\n      if (line.match(/\\\\begin\\{(\\w+)\\}/)) {\r\n        const { node, consumed } = this.parseLatexEnvironment(lines, i);\r\n        if (node) nodes.push(node);\r\n        i += consumed;\r\n        continue;\r\n      }\r\n\r\n      // Inline equations and text\r\n      const lineNodes = this.parseLineWithInlineEquations(line);\r\n      nodes.push(...lineNodes);\r\n\r\n      i++;\r\n    }\r\n\r\n    return nodes.slice(0, this.options.maxBlocks || 100);\r\n  }\r\n\r\n  private parseBlockEquation(lines: string[], startIdx: number): { node: ASTNode | null; consumed: number } {\r\n    const startLine = lines[startIdx];\r\n    let equationContent = '';\r\n    let i = startIdx;\r\n\r\n    // Handle single line $$equation$$\r\n    if (startLine.startsWith('$$') && startLine.endsWith('$$') && startLine.length > 4) {\r\n      equationContent = startLine.slice(2, -2).trim();\r\n      return {\r\n        node: this.createEquationNode(equationContent, true),\r\n        consumed: 1\r\n      };\r\n    }\r\n\r\n    // Handle multi-line $$...$$\r\n    if (startLine === '$$') {\r\n      i++;\r\n      const equationLines: string[] = [];\r\n      \r\n      while (i < lines.length && lines[i].trim() !== '$$') {\r\n        equationLines.push(lines[i]);\r\n        i++;\r\n      }\r\n\r\n      if (i >= lines.length) {\r\n        // No closing $$, treat as text\r\n        return { node: this.createTextNode(lines[startIdx]), consumed: 1 };\r\n      }\r\n\r\n      equationContent = equationLines.join('\\n').trim();\r\n    } else {\r\n      // Single line starting with $$\r\n      equationContent = startLine.slice(2).trim();\r\n    }\r\n\r\n    if (!equationContent) {\r\n      return { node: null, consumed: i - startIdx + 1 };\r\n    }\r\n\r\n    const truncatedExpression = this.truncateContent(equationContent, this.maxEquationLength);\r\n    \r\n    return {\r\n      node: this.createEquationNode(truncatedExpression, true),\r\n      consumed: i - startIdx + 1\r\n    };\r\n  }\r\n\r\n  private parseLatexEnvironment(lines: string[], startIdx: number): { node: ASTNode | null; consumed: number } {\r\n    const startLine = lines[startIdx];\r\n    const envMatch = startLine.match(/\\\\begin\\{(\\w+)\\}/);\r\n    \r\n    if (!envMatch) {\r\n      return { node: this.createTextNode(startLine), consumed: 1 };\r\n    }\r\n\r\n    const envName = envMatch[1];\r\n    const envLines: string[] = [startLine];\r\n    let i = startIdx + 1;\r\n\r\n    // Find matching \\end{environment}\r\n    while (i < lines.length) {\r\n      envLines.push(lines[i]);\r\n      if (lines[i].includes(`\\\\end{${envName}}`)) {\r\n        break;\r\n      }\r\n      i++;\r\n    }\r\n\r\n    if (i >= lines.length) {\r\n      // No matching \\end found\r\n      return { node: this.createTextNode(startLine), consumed: 1 };\r\n    }\r\n\r\n    const content = envLines.join('\\n');\r\n\r\n    // Handle different LaTeX environments\r\n    switch (envName) {\r\n      case 'equation':\r\n      case 'align':\r\n      case 'gather':\r\n      case 'multline':\r\n      case 'eqnarray':\r\n      case 'alignat':\r\n        return {\r\n          node: this.createEquationNode(content, true),\r\n          consumed: i - startIdx + 1\r\n        };\r\n\r\n      case 'itemize':\r\n      case 'enumerate':\r\n        return {\r\n          node: this.parseLatexList(content, envName),\r\n          consumed: i - startIdx + 1\r\n        };\r\n\r\n      case 'tabular':\r\n      case 'array':\r\n      case 'matrix':\r\n      case 'pmatrix':\r\n      case 'bmatrix':\r\n        return {\r\n          node: this.parseLatexTable(content),\r\n          consumed: i - startIdx + 1\r\n        };\r\n\r\n      case 'figure':\r\n      case 'table':\r\n        return {\r\n          node: this.parseLatexFloat(content, envName),\r\n          consumed: i - startIdx + 1\r\n        };\r\n\r\n      default:\r\n        // Unknown environment, treat as code\r\n        return {\r\n          node: this.createCodeNode(content, 'latex', true),\r\n          consumed: i - startIdx + 1\r\n        };\r\n    }\r\n  }\r\n\r\n  private parseLineWithInlineEquations(line: string): ASTNode[] {\r\n    if (!line.includes('$')) {\r\n      return line.trim() ? [this.createTextNode(line)] : [];\r\n    }\r\n\r\n    const nodes: ASTNode[] = [];\r\n    const parts = this.splitInlineEquations(line);\r\n\r\n    for (const part of parts) {\r\n      if (part.isEquation) {\r\n        const truncatedExpression = this.truncateContent(part.content, this.maxEquationLength);\r\n        nodes.push(this.createEquationNode(truncatedExpression, false));\r\n      } else if (part.content.trim()) {\r\n        nodes.push(this.createTextNode(part.content));\r\n      }\r\n    }\r\n\r\n    return nodes;\r\n  }\r\n\r\n  private splitInlineEquations(line: string): Array<{ content: string; isEquation: boolean }> {\r\n    const parts: Array<{ content: string; isEquation: boolean }> = [];\r\n    let current = '';\r\n    let inEquation = false;\r\n    let i = 0;\r\n\r\n    while (i < line.length) {\r\n      const char = line[i];\r\n      const nextChar = line[i + 1];\r\n\r\n      if (char === '$') {\r\n        if (nextChar === '$') {\r\n          // Double $ - skip for now (should be handled as block)\r\n          current += '$$';\r\n          i += 2;\r\n        } else {\r\n          // Single $ - inline equation delimiter\r\n          if (current) {\r\n            parts.push({ content: current, isEquation: inEquation });\r\n            current = '';\r\n          }\r\n          inEquation = !inEquation;\r\n          i++;\r\n        }\r\n      } else {\r\n        current += char;\r\n        i++;\r\n      }\r\n    }\r\n\r\n    if (current) {\r\n      parts.push({ content: current, isEquation: inEquation });\r\n    }\r\n\r\n    return parts;\r\n  }\r\n\r\n  private parseLatexList(content: string, envType: string): ASTNode {\r\n    const items: ASTNode[] = [];\r\n    \r\n    // Extract content between \\begin and \\end\r\n    const contentMatch = content.match(/\\\\begin\\{\\w+\\}([\\s\\S]*?)\\\\end\\{\\w+\\}/);\r\n    const listContent = contentMatch ? contentMatch[1] : content;\r\n    \r\n    // Find all \\item entries\r\n    const itemMatches = listContent.match(/\\\\item\\s*([^\\n\\\\]*(?:\\n(?!\\\\item)[^\\n\\\\]*)*)/g);\r\n\r\n    if (itemMatches) {\r\n      for (const match of itemMatches) {\r\n        const itemContent = match.replace(/\\\\item\\s*/, '').trim();\r\n        if (itemContent) {\r\n          items.push(this.createListItemNode(itemContent));\r\n        }\r\n      }\r\n    }\r\n\r\n    const listType = envType === 'enumerate' ? 'numbered' : 'bulleted';\r\n    return this.createListNode(items, listType);\r\n  }\r\n\r\n  private parseLatexTable(content: string): ASTNode {\r\n    // Extract content between \\begin and \\end\r\n    const contentMatch = content.match(/\\\\begin\\{\\w+\\}(?:\\{[^}]*\\})?([\\s\\S]*?)\\\\end\\{\\w+\\}/);\r\n    const tableContent = contentMatch ? contentMatch[1] : content;\r\n    \r\n    // Split by lines and filter out LaTeX commands\r\n    const lines = tableContent.split('\\n')\r\n      .map(line => line.trim())\r\n      .filter(line => \r\n        line && \r\n        !line.startsWith('\\\\hline') && \r\n        !line.startsWith('\\\\cline') &&\r\n        !line.startsWith('\\\\toprule') &&\r\n        !line.startsWith('\\\\midrule') &&\r\n        !line.startsWith('\\\\bottomrule')\r\n      );\r\n\r\n    if (lines.length === 0) {\r\n      return this.createTextNode(content);\r\n    }\r\n\r\n    // Parse table rows (split by &, end with \\\\)\r\n    const rows = lines.map(line => {\r\n      const cleaned = line.replace(/\\\\\\\\/g, '').trim();\r\n      return cleaned.split('&').map(cell => cell.trim());\r\n    }).filter(row => row.length > 1);\r\n\r\n    if (rows.length === 0) {\r\n      return this.createTextNode(content);\r\n    }\r\n\r\n    // Use first row as headers\r\n    const headers = rows[0];\r\n    const dataRows = rows.slice(1);\r\n\r\n    return this.createTableNode(headers, dataRows);\r\n  }\r\n\r\n  private parseLatexFloat(content: string, _envType: string): ASTNode {\r\n    // Extract content between \\begin and \\end\r\n    const contentMatch = content.match(/\\\\begin\\{\\w+\\}([\\s\\S]*?)\\\\end\\{\\w+\\}/);\r\n    const floatContent = contentMatch ? contentMatch[1] : content;\r\n    \r\n    // Look for \\caption\r\n    const captionMatch = floatContent.match(/\\\\caption\\{([^}]*)\\}/);\r\n    const caption = captionMatch ? captionMatch[1] : '';\r\n    \r\n    // Look for \\includegraphics or \\centering content\r\n    const includeMatch = floatContent.match(/\\\\includegraphics(?:\\[[^\\]]*\\])?\\{([^}]*)\\}/);\r\n    \r\n    if (includeMatch) {\r\n      const imagePath = includeMatch[1];\r\n      return this.createMediaNode('image', imagePath, caption);\r\n    }\r\n    \r\n    // If no specific content found, treat as text block\r\n    const cleanContent = floatContent\r\n      .replace(/\\\\caption\\{[^}]*\\}/g, '')\r\n      .replace(/\\\\centering/g, '')\r\n      .replace(/\\\\label\\{[^}]*\\}/g, '')\r\n      .trim();\r\n    \r\n    if (cleanContent) {\r\n      return this.createTextNode(cleanContent + (caption ? `\\n\\n${caption}` : ''));\r\n    }\r\n    \r\n    return this.createTextNode(caption || content);\r\n  }\r\n\r\n  /**\r\n   * Validate LaTeX syntax (basic validation)\r\n   */\r\n  static validateLatex(content: string): { isValid: boolean; errors: string[] } {\r\n    const errors: string[] = [];\r\n\r\n    // Check for balanced braces\r\n    let braceCount = 0;\r\n    for (const char of content) {\r\n      if (char === '{') braceCount++;\r\n      if (char === '}') braceCount--;\r\n      if (braceCount < 0) {\r\n        errors.push('Unmatched closing brace');\r\n        break;\r\n      }\r\n    }\r\n    if (braceCount > 0) {\r\n      errors.push('Unmatched opening brace');\r\n    }\r\n\r\n    // Check for balanced environments\r\n    const beginMatches = content.match(/\\\\begin\\{(\\w+)\\}/g) || [];\r\n    const endMatches = content.match(/\\\\end\\{(\\w+)\\}/g) || [];\r\n    \r\n    if (beginMatches.length !== endMatches.length) {\r\n      errors.push('Unmatched LaTeX environments');\r\n    }\r\n\r\n    // Check for balanced equation delimiters\r\n    const singleDollarCount = (content.match(/(?<!\\$)\\$(?!\\$)/g) || []).length;\r\n    if (singleDollarCount % 2 !== 0) {\r\n      errors.push('Unmatched equation delimiters ($)');\r\n    }\r\n\r\n    return {\r\n      isValid: errors.length === 0,\r\n      errors\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract all equations from LaTeX content\r\n   */\r\n  static extractEquations(content: string): string[] {\r\n    const equations: string[] = [];\r\n    \r\n    // Block equations $$...$$\r\n    const blockMatches = content.match(/\\$\\$([\\s\\S]*?)\\$\\$/g);\r\n    if (blockMatches) {\r\n      equations.push(...blockMatches.map(match => match.slice(2, -2).trim()));\r\n    }\r\n    \r\n    // Inline equations $...$\r\n    const inlineMatches = content.match(/(?<!\\$)\\$([^$]+)\\$(?!\\$)/g);\r\n    if (inlineMatches) {\r\n      equations.push(...inlineMatches.map(match => match.slice(1, -1).trim()));\r\n    }\r\n    \r\n    // Environment equations\r\n    const envMatches = content.match(/\\\\begin\\{(equation|align|gather|multline)\\}([\\s\\S]*?)\\\\end\\{\\1\\}/g);\r\n    if (envMatches) {\r\n      equations.push(...envMatches);\r\n    }\r\n    \r\n    return equations;\r\n  }\r\n}"],"version":3}